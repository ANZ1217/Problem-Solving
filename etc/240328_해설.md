# A. 2018 연세대학교 프로그래밍 경진대회 - 완탐
1+x+x^2=n을 만족하는 x를 찾으면 됩니다.  
입력 조건에 의해 x는 100이하입니다. 완전탐색으로 찾으면 됩니다.  

# B. 고인물이 싫어요 - 그래프 순회
물탱크가 파이프로 이어져 있고, 파이프를 거쳐 이동할 수 있는 물탱크들이 중요하다고 합니다.  
따라서 각 물탱크가 어떤 Component에 속하는지, 각 Component에 청정수와 고인물이 각각 몇개인지 저장하면 됩니다.  
DFS등 그래프 탐색 한 번 하면 됩니다. 혹시 Union Find를 먼저 생각하셨다면 반성의 시간을 가지도록 합시다.

# C. 잘못 구현한 에라토스테네스의 체 - 수학
for문을 잘 분석해보면, y = floor(n / x)를 1부터 n까지 모든 x에 대해 더하면 됩니다.  
y의 값이 될 수 있는 수들이 몇개인지 생각해 봅시다.  
y >= sqrt n인 경우 O(sqrt n)개 (x가 1부터 sqrt n까지임)  
y <= sqrt n인 경우 O(sqrt n)개 (y가 sqrt n보다 작으므로 당연함)  
따라서 가능한 y O(sqrt n)개에 대해 그 y가 될 수 있는 x의 개수를 각각 세주면 됩니다.

# D. kdh9949 - DAG DP
그래프가 주어지는데, 이 그래프에서 이용할 수 있는 간선과 그 간선의 이동방향은 정해져 있습니다.  
이용가능한 간선들만 포함하도록 유향 그래프를 새로 만듭시다.  
이 그래프에 사이클이 있으면 답은 무한입니다.  
그렇지 않다면, 이 그래프는 DAG입니다. 따라서 DP로 최장거리를 구할 수 있습니다.  

# E. Flat Earth - 수학
그림을 반의반으로 쪼개보면 간단합니다.  
n+(n-1)+(n-2)... 와 같은 식인데 항이 k개입니다. 자세한 설명은 생략합니다.  

# F. 소수를 분수로 - 구현
다들 어렸을 때 순환소수를 분수로 바꾸는 법을 배웠을 것이라고 생각합니다.  
그럼 이건 그냥 파싱 구현 문제입니다. 분자와 분모가 서로소여야 된다니까 최대공약수도 구해주면 됩니다.  

# G. Swap Space - 그리디
그냥 두 드라이브만 있다고 합시다. 둘 중 뭘 먼저 추가하는게 이득일까요?  
1. 용량이 늘어나는 드라이브 먼저  
2. 둘다 늘어나면 a가 작은 드라이브 먼저  
3. 둘다 줄어들면 b가 큰 드라이브 먼저 (이해가 잘 안되면 2의 역순이라고 생각하면 됩니다)

따라서 Exchange argument에 의해 저 기준으로 정렬한 후 차례대로 추가하는게 가장 이득입니다. 추가하면서 부족한만큼 더하면 됩니다.  
Exchange argument 얘기가 디코방에 나와서 추가했습니다. 혹시 최준형이 못풀었다면 반성하도록 합시다.

# H. 트리플 소트 - Ad-hoc
연속한 세 원소를 뒤집는다는 말은, 다시 말하면 a_i와 a_{i+2}를 swap한다는 소리입니다.  
따라서 홇수 인덱스와 짝수 인덱스간에는 원소가 이동할 수 없습니다.  
그럼 홀수/짝수 인덱스 각각 정렬한다음 최종 정렬되어있는지 보면 됩니다.
